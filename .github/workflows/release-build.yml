# CMake single-platform CI + automatic GitHub Release with the built binary as an asset.
# Builds & tests on PRs and pushes; creates a GitHub Release only for successful pushes to master.
name: release build

# Give the workflow permission to create releases (write access to repository contents).
permissions:
  contents: write

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]

env:
  BUILD_TYPE: Release

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      package-name: ${{ steps.package.outputs.package_name }}
    steps:
      - uses: actions/checkout@v4

      - name: CMake
        run: cmake -B ${{ github.workspace }}/build -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }}

      - name: Build
        run: cmake --build ${{ github.workspace }}/build --config ${{ env.BUILD_TYPE }}

      - name: Test
        working-directory: ${{ github.workspace }}/build
        run: ctest -C ${{ env.BUILD_TYPE }}

      - name: Package
        id: package
        run: |
          BUILD_DIR="${GITHUB_WORKSPACE}/build"
          RELEASE_DIR="${GITHUB_WORKSPACE}/release"
          PACKAGE_DIR="${GITHUB_WORKSPACE}/package"
          mkdir -p "$RELEASE_DIR" "$PACKAGE_DIR"
          if [ ! -d "$BUILD_DIR" ]; then
            echo "Build directory not found: $BUILD_DIR"
            exit 1
          fi
          
          # Find the executable (case-insensitive match for UEFIRomExtract)
          EXECUTABLE=$(find "$BUILD_DIR" -maxdepth 1 -type f -iname "uefiromextract" -executable | head -n 1)
          if [ -z "$EXECUTABLE" ]; then
            echo "ERROR: Could not find UEFIRomExtract executable"
            exit 1
          fi
          
          # Copy executable to package directory
          cp "$EXECUTABLE" "$PACKAGE_DIR/"
          
          # Copy README.md from repository root
          if [ -f "${GITHUB_WORKSPACE}/README.md" ]; then
            cp "${GITHUB_WORKSPACE}/README.md" "$PACKAGE_DIR/"
          else
            echo "WARNING: README.md not found"
          fi
          
          # Create REPO_LINK.txt with repository URL
          echo "https://github.com/${GITHUB_REPOSITORY}" > "$PACKAGE_DIR/github.txt"
          
          # Create package name
          SHORT_SHA="$(echo "${GITHUB_SHA}" | cut -c1-8)"
          PACKAGE_NAME="uefiromextract-${SHORT_SHA}.tar.gz"
          
          tar -C "$PACKAGE_DIR" -czf "$RELEASE_DIR/$PACKAGE_NAME" .
          
          echo "PACKAGE_PATH=$RELEASE_DIR/$PACKAGE_NAME" >> $GITHUB_ENV
          echo "PACKAGE_NAME=$PACKAGE_NAME" >> $GITHUB_ENV
          echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT

      - name: Upload packaged artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-package
          path: ${{ env.PACKAGE_PATH }}

  release:
    needs: build
    runs-on: ubuntu-latest
    # Only create a release for successful runs triggered by a push to the master branch.
    if: needs.build.result == 'success' && github.event_name == 'push' && github.ref == 'refs/heads/master'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history and tags

      - name: Determine next version
        id: version
        run: |
          # Fetch all tags
          git fetch --tags
          
          # Find all v1.0.x tags and extract the patch version
          LATEST_TAG=$(git tag -l "v1.0.*" | sort -V | tail -n 1)
          
          if [ -z "$LATEST_TAG" ]; then
            # No v1.0.x tags exist, start with v1.0.0
            NEW_VERSION="v1.0.0"
          else
            # Extract patch version and increment it
            PATCH=$(echo "$LATEST_TAG" | sed 's/v1\.0\.//')
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="v1.0.$NEW_PATCH"
          fi
          
          echo "New version: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Download packaged artifact
        uses: actions/download-artifact@v4
        with:
          name: release-package
          path: release

      - name: Create GitHub release
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        uses: actions/create-release@v1
        with:
          tag_name: ${{ steps.version.outputs.new_version }}
          release_name: Release ${{ steps.version.outputs.new_version }}
          body: |
            Automated release created by CI for version ${{ steps.version.outputs.new_version }} (commit ${{ github.sha }}).
          draft: false
          prerelease: false

      - name: Upload release asset
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: release/${{ needs.build.outputs.package-name }}
          asset_name: UEFIRomExtract-${{ steps.version.outputs.new_version }}.tar.gz
          asset_content_type: application/gzip
